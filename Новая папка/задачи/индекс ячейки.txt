что будет, если к одному и тому же индексу, будут обращаться множество других индексов, идея в том что у каждого живого индекса, которые находяться в массиве живых индексов, будет возможность взаимодействовать с масивом не всеобщим массивом индексов, но если проблем, чтобы сделать из неживого индекса живой не состовляет труда её решить, то если обращаться к уже живому индексу создаеться конфликт который нужно правильно обработать в коде.

массив с пустыми ячейками с нулями, если ячейка массива заполнена единицей, то индекс массива, БЕРЕТЬСЯ И создается переменная инт с номером этого индекса, и переноситься в массив меняющий логику ячеек, просто если они пусты, логика меняться не должна, а если заполнены, то эти индексы должны выноситься в массив с меняющейся логикой, но ячейки должны перепроверяться по таймеру в 1 секунду, заполнена она или нет, если нет, то пропустить ячейку и перехожить к следующей, если да то записать ее индекс и передать этот индекс в массив, сам массив обоработчик должен распознавать индекс, тоесть у него должно быть четкое понимание с какого участка массива он пришел, 


и должен перестраивать этот одномерный массив так, чтобы полусился прямоугольник, из задающийся при учитывании размера создании одномерного массива, просто его будут представлять в двух массивах, которых не будет на самом деле, просто будет представление при помощи формулы index = row * M + column, а также я хочу, чтобы ты дал мне формулы, которые мне помогут распределить в трехмерном пространстве точки так, чтобы они были равноудалены друг от друга, но при этом составляли плоскость в трехмерном пространстве, то есть это надо будет сделать через позиционирование x y z, в движке godot 4.3 на gdscript. давай действовать по порядку, не лепи все в кучу , я просто обозначил, что мне нужно в итоге в конце, но я бы разбил все это на несколько подзадач, и приступал к ним поочередно, только после того как выполнил другую предыдущую.

как все идеи предствавить в виде ооп таблици из кода, чтобы ты нарисовал мне таблицу из нулей и еденичек, в программном виде

extends Node

const ARRAY_SIZE = 64
var bit_array: Array = []
var filled_indices: Array = []

func _ready():
	bit_array.resize(ARRAY_SIZE) # Инициализация битового массива
	for i in range(ARRAY_SIZE):
		bit_array[i] = false  # Изначально все ячейки пустые
		
	
	
func _on_timer_timeout() -> void:
	for i in range(ARRAY_SIZE):
		if bit_array[i]:  # Если ячейка заполнена
			if !is_cell_filled(i):  # Проверка, заполнена ли ячейка
				filled_indices.erase(i)  # Удаляем индекс из массива заполненных ячеек
		else:
			if i in filled_indices:  # Если ячейка была заполнена, но теперь пустая
				filled_indices.erase(i)  # Удаляем индекс из массива заполненных ячеек
	
	update_cell(0, true)
	
	var testcell = is_cell_filled(0)
	print(testcell)
	var testcell2 = is_cell_filled(1)
	print(testcell2)
	var testcell3 = is_cell_filled(2)
	print(testcell3)

func is_cell_filled(index: int) -> bool:
	if index < 0 or index >= ARRAY_SIZE:
		pass
	return bit_array[index]  # Проверяем состояние ячейки в битовом массиве

func update_cell(index: int, state: bool):
	bit_array[index] = state  # Обновляем состояние ячейки
	if state and not filled_indices.has(index):
		filled_indices.append(index)  # Добавляем индекс в массив, если ячейка заполнена
	elif not state and filled_indices.has(index):
		filled_indices.erase(index)  # Удаляем индекс, если ячейка стала пустой
