массив с пустыми ячейками с нулями, если ячейка массива заполнена единицей, то индекс массива, БЕРЕТЬСЯ И создается переменная инт с номером этого индекса, и переноситься в массив меняющий логику ячеек, просто если они пусты, логика меняться не должна, а если заполнены, то эти индексы должны выноситься в массив с меняющейся логикой, но ячейки должны перепроверяться по таймеру в 1 секунду, заполнена она или нет, если нет, то пропустить ячейку и перехожить к следующей, если да то записать ее индекс и передать этот индекс в массив, сам массив обоработчик должен распознавать индекс, тоесть у него должно быть четкое понимание с какого участка массива он пришел, 


и должен перестраивать этот одномерный массив так, чтобы полусился прямоугольник, из задающийся при учитывании размера создании одномерного массива, просто его будут представлять в двух массивах, которых не будет на самом деле, просто будет представление при помощи формулы index = row * M + column, а также я хочу, чтобы ты дал мне формулы, которые мне помогут распределить в трехмерном пространстве точки так, чтобы они были равноудалены друг от друга, но при этом составляли плоскость в трехмерном пространстве, то есть это надо будет сделать через позиционирование x y z, в движке godot 4.3 на gdscript. давай действовать по порядку, не лепи все в кучу , я просто обозначил, что мне нужно в итоге в конце, но я бы разбил все это на несколько подзадач, и приступал к ним поочередно, только после того как выполнил другую предыдущую. 


11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
extends Node

var bit_array: BitArray = BitArray()
var processed_indices: Array = []
var timer: Timer

func _ready():
    # Инициализация битового массива
    var size = 100  # Размер массива
    bit_array.resize(size)
    
    # Заполнение массива случайными значениями (true/false)
    for i in range(size):
        bit_array.set_bit(i, randi() % 2 == 1)  # Случайно устанавливаем true или false

    # Настройка таймера
    timer = Timer.new()
    timer.wait_time = 1.0
    timer.connect("timeout", self, "_on_timer_timeout")
    add_child(timer)
    timer.start()

func _on_timer_timeout():
    processed_indices.clear()  # Очистка обработанных индексов
    for i in range(bit_array.size()):
        if bit_array.get_bit(i):  # Если ячейка заполнена (true)
            processed_indices.append(i)  # Добавляем индекс в массив обработанных
            # Здесь можно добавить логику для обработки заполненных ячеек

    # Выводим обработанные индексы
    print("Обработанные индексы:", processed_indices)

# Дополнительные функции для работы с массивом можно добавить здесь


1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111


extends Node

const ARRAY_SIZE = 100
# Битовый массив
var bit_array: Array = []
# Массив для заполненных ячеек
var filled_indices: Array = []

func _ready():
    # Инициализация битового массива
    bit_array.resize(ARRAY_SIZE)
    for i in range(ARRAY_SIZE):
        bit_array[i] = false  # Изначально все ячейки пустые


func _on_check_timer_timeout():
    # Проверка состояния ячеек
    for i in range(ARRAY_SIZE):
        if bit_array[i]:  # Если ячейка заполнена
            if !is_cell_filled(i):  # Проверка, заполнена ли ячейка
                filled_indices.erase(i)  # Удаляем индекс из массива заполненных ячеек
        else:
            if i in filled_indices:  # Если ячейка была заполнена, но теперь пустая
                filled_indices.erase(i)  # Удаляем индекс из массива заполненных ячеек

func is_cell_filled(index: int) -> bool:
    # Здесь должна быть логика проверки состояния ячейки
    # Например, возвращаем true, если ячейка заполнена
    return bit_array[index]  # Замените на Вашу логику

func set_cell(index: int, value: bool):
    # Устанавливаем значение ячейки и обновляем массив заполненных индексов
    bit_array[index] = value
    if value and !filled_indices.has(index):
        filled_indices.append(index)  # Добавляем индекс в массив заполненных ячеек
    elif !value and filled_indices.has(index):
        filled_indices.erase(index)  # Удаляем индекс из массива заполненных ячеек


111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111


extends Node

var size = 10  # Размер массива
var bit_array: BitArray = BitArray(size)  # Битовый массив
var filled_indices: Array = []  # Массив с заполненными индексами
var timer: Timer

func _ready():
 

func _on_timer_timeout():
    for i in filled_indices:
        if not is_cell_filled(i):  # Проверяем состояние ячейки
            filled_indices.erase(i)  # Удаляем индекс, если ячейка не заполнена


func update_cell(index: int, state: bool):
    bit_array[index] = state  # Обновляем состояние ячейки
    if state and not filled_indices.has(index):
        filled_indices.append(index)  # Добавляем индекс в массив, если ячейка заполнена
    elif not state and filled_indices.has(index):
        filled_indices.erase(index)  # Удаляем индекс, если ячейка стала пустой
